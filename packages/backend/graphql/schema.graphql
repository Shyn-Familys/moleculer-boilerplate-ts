# A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
input BooleanFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Boolean

  # Not equal to the specified value.
  notEqualTo: Boolean

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Boolean

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Boolean

  # Included in the specified list.
  in: [Boolean!]

  # Not included in the specified list.
  notIn: [Boolean!]

  # Less than the specified value.
  lessThan: Boolean

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Boolean

  # Greater than the specified value.
  greaterThan: Boolean

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Boolean
}

# All input for the create `Organization` mutation.
input CreateOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Organization` to be created by this mutation.
  organization: OrganizationInput!
}

# The output of our create `Organization` mutation.
type CreateOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Organization` that was created by this mutation.
  organization: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Organization`. May be used by Relay 1.
  organizationEdge(
    # The method to use when ordering `Organization`.
    orderBy: [OrganizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

# All input for the create `Permission` mutation.
input CreatePermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Permission` to be created by this mutation.
  permission: PermissionInput!
}

# The output of our create `Permission` mutation.
type CreatePermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Permission` that was created by this mutation.
  permission: Permission

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Permission`. May be used by Relay 1.
  permissionEdge(
    # The method to use when ordering `Permission`.
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

# All input for the create `Profile` mutation.
input CreateProfileInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Profile` to be created by this mutation.
  profile: ProfileInput!
}

# The output of our create `Profile` mutation.
type CreateProfilePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Profile` that was created by this mutation.
  profile: Profile

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Profile`.
  userById: User

  # An edge for our `Profile`. May be used by Relay 1.
  profileEdge(
    # The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
}

# All input for the create `Project` mutation.
input CreateProjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Project` to be created by this mutation.
  project: ProjectInput!
}

# The output of our create `Project` mutation.
type CreateProjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Project` that was created by this mutation.
  project: Project

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Project`.
  userByCreatedBy: User

  # An edge for our `Project`. May be used by Relay 1.
  projectEdge(
    # The method to use when ordering `Project`.
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

# All input for the create `ProjectsOnRole` mutation.
input CreateProjectsOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ProjectsOnRole` to be created by this mutation.
  projectsOnRole: ProjectsOnRoleInput!
}

# The output of our create `ProjectsOnRole` mutation.
type CreateProjectsOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnRole` that was created by this mutation.
  projectsOnRole: ProjectsOnRole

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Project` that is related to this `ProjectsOnRole`.
  projectByProjectId: Project

  # Reads a single `Role` that is related to this `ProjectsOnRole`.
  roleByRoleId: Role

  # An edge for our `ProjectsOnRole`. May be used by Relay 1.
  projectsOnRoleEdge(
    # The method to use when ordering `ProjectsOnRole`.
    orderBy: [ProjectsOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnRolesEdge
}

# All input for the create `ProjectsOnUser` mutation.
input CreateProjectsOnUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ProjectsOnUser` to be created by this mutation.
  projectsOnUser: ProjectsOnUserInput!
}

# The output of our create `ProjectsOnUser` mutation.
type CreateProjectsOnUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnUser` that was created by this mutation.
  projectsOnUser: ProjectsOnUser

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `ProjectsOnUser`.
  userByUserId: User

  # Reads a single `Project` that is related to this `ProjectsOnUser`.
  projectByProjectId: Project

  # An edge for our `ProjectsOnUser`. May be used by Relay 1.
  projectsOnUserEdge(
    # The method to use when ordering `ProjectsOnUser`.
    orderBy: [ProjectsOnUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnUsersEdge
}

# All input for the create `Role` mutation.
input CreateRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Role` to be created by this mutation.
  role: RoleInput!
}

# The output of our create `Role` mutation.
type CreateRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Role` that was created by this mutation.
  role: Role

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Role`. May be used by Relay 1.
  roleEdge(
    # The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

# All input for the create `RolesOnPermission` mutation.
input CreateRolesOnPermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `RolesOnPermission` to be created by this mutation.
  rolesOnPermission: RolesOnPermissionInput!
}

# The output of our create `RolesOnPermission` mutation.
type CreateRolesOnPermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `RolesOnPermission` that was created by this mutation.
  rolesOnPermission: RolesOnPermission

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Role` that is related to this `RolesOnPermission`.
  roleByRoleId: Role

  # Reads a single `Permission` that is related to this `RolesOnPermission`.
  permissionByPermissionId: Permission

  # An edge for our `RolesOnPermission`. May be used by Relay 1.
  rolesOnPermissionEdge(
    # The method to use when ordering `RolesOnPermission`.
    orderBy: [RolesOnPermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesOnPermissionsEdge
}

# All input for the create `User` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our create `User` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

# All input for the create `UsersOnRole` mutation.
input CreateUsersOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `UsersOnRole` to be created by this mutation.
  usersOnRole: UsersOnRoleInput!
}

# The output of our create `UsersOnRole` mutation.
type CreateUsersOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UsersOnRole` that was created by this mutation.
  usersOnRole: UsersOnRole

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `UsersOnRole`.
  userByUserId: User

  # Reads a single `Role` that is related to this `UsersOnRole`.
  roleByRoleId: Role

  # An edge for our `UsersOnRole`. May be used by Relay 1.
  usersOnRoleEdge(
    # The method to use when ordering `UsersOnRole`.
    orderBy: [UsersOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersOnRolesEdge
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
input DatetimeFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Datetime

  # Not equal to the specified value.
  notEqualTo: Datetime

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Datetime

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Datetime

  # Included in the specified list.
  in: [Datetime!]

  # Not included in the specified list.
  notIn: [Datetime!]

  # Less than the specified value.
  lessThan: Datetime

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Datetime

  # Greater than the specified value.
  greaterThan: Datetime

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Datetime
}

# All input for the `deleteOrganizationById` mutation.
input DeleteOrganizationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteOrganization` mutation.
input DeleteOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Organization` to be deleted.
  nodeId: ID!
}

# The output of our delete `Organization` mutation.
type DeleteOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Organization` that was deleted by this mutation.
  organization: Organization
  deletedOrganizationId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Organization`. May be used by Relay 1.
  organizationEdge(
    # The method to use when ordering `Organization`.
    orderBy: [OrganizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

# All input for the `deletePermissionById` mutation.
input DeletePermissionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePermission` mutation.
input DeletePermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Permission` to be deleted.
  nodeId: ID!
}

# The output of our delete `Permission` mutation.
type DeletePermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Permission` that was deleted by this mutation.
  permission: Permission
  deletedPermissionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Permission`. May be used by Relay 1.
  permissionEdge(
    # The method to use when ordering `Permission`.
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

# All input for the `deleteProfileById` mutation.
input DeleteProfileByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: String!
}

# All input for the `deleteProfile` mutation.
input DeleteProfileInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Profile` to be deleted.
  nodeId: ID!
}

# The output of our delete `Profile` mutation.
type DeleteProfilePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Profile` that was deleted by this mutation.
  profile: Profile
  deletedProfileId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Profile`.
  userById: User

  # An edge for our `Profile`. May be used by Relay 1.
  profileEdge(
    # The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
}

# All input for the `deleteProjectById` mutation.
input DeleteProjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteProject` mutation.
input DeleteProjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Project` to be deleted.
  nodeId: ID!
}

# The output of our delete `Project` mutation.
type DeleteProjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Project` that was deleted by this mutation.
  project: Project
  deletedProjectId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Project`.
  userByCreatedBy: User

  # An edge for our `Project`. May be used by Relay 1.
  projectEdge(
    # The method to use when ordering `Project`.
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

# All input for the `deleteProjectsOnRoleByProjectIdAndRoleId` mutation.
input DeleteProjectsOnRoleByProjectIdAndRoleIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  projectId: Int!
  roleId: Int!
}

# All input for the `deleteProjectsOnRole` mutation.
input DeleteProjectsOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ProjectsOnRole` to be deleted.
  nodeId: ID!
}

# The output of our delete `ProjectsOnRole` mutation.
type DeleteProjectsOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnRole` that was deleted by this mutation.
  projectsOnRole: ProjectsOnRole
  deletedProjectsOnRoleId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Project` that is related to this `ProjectsOnRole`.
  projectByProjectId: Project

  # Reads a single `Role` that is related to this `ProjectsOnRole`.
  roleByRoleId: Role

  # An edge for our `ProjectsOnRole`. May be used by Relay 1.
  projectsOnRoleEdge(
    # The method to use when ordering `ProjectsOnRole`.
    orderBy: [ProjectsOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnRolesEdge
}

# All input for the `deleteProjectsOnUserByUserIdAndProjectId` mutation.
input DeleteProjectsOnUserByUserIdAndProjectIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: String!
  projectId: Int!
}

# All input for the `deleteProjectsOnUser` mutation.
input DeleteProjectsOnUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ProjectsOnUser` to be deleted.
  nodeId: ID!
}

# The output of our delete `ProjectsOnUser` mutation.
type DeleteProjectsOnUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnUser` that was deleted by this mutation.
  projectsOnUser: ProjectsOnUser
  deletedProjectsOnUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `ProjectsOnUser`.
  userByUserId: User

  # Reads a single `Project` that is related to this `ProjectsOnUser`.
  projectByProjectId: Project

  # An edge for our `ProjectsOnUser`. May be used by Relay 1.
  projectsOnUserEdge(
    # The method to use when ordering `ProjectsOnUser`.
    orderBy: [ProjectsOnUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnUsersEdge
}

# All input for the `deleteRoleById` mutation.
input DeleteRoleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteRole` mutation.
input DeleteRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Role` to be deleted.
  nodeId: ID!
}

# The output of our delete `Role` mutation.
type DeleteRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Role` that was deleted by this mutation.
  role: Role
  deletedRoleId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Role`. May be used by Relay 1.
  roleEdge(
    # The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

# All input for the `deleteRolesOnPermissionByRoleIdAndPermissionId` mutation.
input DeleteRolesOnPermissionByRoleIdAndPermissionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  roleId: Int!
  permissionId: Int!
}

# All input for the `deleteRolesOnPermission` mutation.
input DeleteRolesOnPermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `RolesOnPermission` to be deleted.
  nodeId: ID!
}

# The output of our delete `RolesOnPermission` mutation.
type DeleteRolesOnPermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `RolesOnPermission` that was deleted by this mutation.
  rolesOnPermission: RolesOnPermission
  deletedRolesOnPermissionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Role` that is related to this `RolesOnPermission`.
  roleByRoleId: Role

  # Reads a single `Permission` that is related to this `RolesOnPermission`.
  permissionByPermissionId: Permission

  # An edge for our `RolesOnPermission`. May be used by Relay 1.
  rolesOnPermissionEdge(
    # The method to use when ordering `RolesOnPermission`.
    orderBy: [RolesOnPermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesOnPermissionsEdge
}

# All input for the `deleteUserById` mutation.
input DeleteUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: String!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  nodeId: ID!
}

# The output of our delete `User` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was deleted by this mutation.
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

# All input for the `deleteUsersOnRoleByUserIdAndRoleId` mutation.
input DeleteUsersOnRoleByUserIdAndRoleIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: String!
  roleId: Int!
}

# All input for the `deleteUsersOnRole` mutation.
input DeleteUsersOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UsersOnRole` to be deleted.
  nodeId: ID!
}

# The output of our delete `UsersOnRole` mutation.
type DeleteUsersOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UsersOnRole` that was deleted by this mutation.
  usersOnRole: UsersOnRole
  deletedUsersOnRoleId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `UsersOnRole`.
  userByUserId: User

  # Reads a single `Role` that is related to this `UsersOnRole`.
  roleByRoleId: Role

  # An edge for our `UsersOnRole`. May be used by Relay 1.
  usersOnRoleEdge(
    # The method to use when ordering `UsersOnRole`.
    orderBy: [UsersOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersOnRolesEdge
}

# A filter to be used against Int fields. All fields are combined with a logical ‘and.’
input IntFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Int

  # Not equal to the specified value.
  notEqualTo: Int

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Int

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Int

  # Included in the specified list.
  in: [Int!]

  # Not included in the specified list.
  notIn: [Int!]

  # Less than the specified value.
  lessThan: Int

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Int

  # Greater than the specified value.
  greaterThan: Int

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Int
}

enum LanguageCode {
  EN
  VI
}

# A filter to be used against LanguageCode fields. All fields are combined with a logical ‘and.’
input LanguageCodeFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: LanguageCode

  # Not equal to the specified value.
  notEqualTo: LanguageCode

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: LanguageCode

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: LanguageCode

  # Included in the specified list.
  in: [LanguageCode!]

  # Not included in the specified list.
  notIn: [LanguageCode!]

  # Less than the specified value.
  lessThan: LanguageCode

  # Less than or equal to the specified value.
  lessThanOrEqualTo: LanguageCode

  # Greater than the specified value.
  greaterThan: LanguageCode

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: LanguageCode
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

type Organization implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  code: String!
  name: String!
  description: String!
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `Organization` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input OrganizationCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `code` field.
  code: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’
input OrganizationFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `code` field.
  code: StringFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `description` field.
  description: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [OrganizationFilter!]

  # Checks for any expressions in this list.
  or: [OrganizationFilter!]

  # Negates the expression.
  not: OrganizationFilter
}

# An input for mutations affecting `Organization`
input OrganizationInput {
  id: Int
  code: String!
  name: String!
  description: String!
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `Organization`. Fields that are set will be updated.
input OrganizationPatch {
  id: Int
  code: String
  name: String
  description: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `Organization` values.
type OrganizationsConnection {
  # A list of `Organization` objects.
  nodes: [Organization]!

  # A list of edges which contains the `Organization` and cursor to aid in pagination.
  edges: [OrganizationsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Organization` you could get from the connection.
  totalCount: Int!
}

# A `Organization` edge in the connection.
type OrganizationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Organization` at the end of the edge.
  node: Organization
}

# Methods to use when ordering `Organization`.
enum OrganizationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

type Permission implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime

  # Reads and enables pagination through a set of `RolesOnPermission`.
  rolesOnPermissionsByPermissionId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `RolesOnPermission`.
    orderBy: [RolesOnPermissionsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: RolesOnPermissionCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: RolesOnPermissionFilter
  ): RolesOnPermissionsConnection!
}

# A condition to be used against `Permission` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input PermissionCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `builtin` field.
  builtin: Boolean

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `Permission` object types. All fields are combined with a logical ‘and.’
input PermissionFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `description` field.
  description: StringFilter

  # Filter by the object’s `builtin` field.
  builtin: BooleanFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [PermissionFilter!]

  # Checks for any expressions in this list.
  or: [PermissionFilter!]

  # Negates the expression.
  not: PermissionFilter
}

# An input for mutations affecting `Permission`
input PermissionInput {
  id: Int
  name: String!
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `Permission`. Fields that are set will be updated.
input PermissionPatch {
  id: Int
  name: String
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `Permission` values.
type PermissionsConnection {
  # A list of `Permission` objects.
  nodes: [Permission]!

  # A list of edges which contains the `Permission` and cursor to aid in pagination.
  edges: [PermissionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Permission` you could get from the connection.
  totalCount: Int!
}

# A `Permission` edge in the connection.
type PermissionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Permission` at the end of the edge.
  node: Permission
}

# Methods to use when ordering `Permission`.
enum PermissionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  BUILTIN_ASC
  BUILTIN_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Profile implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: String!
  firstName: String!
  lastName: String!
  language: LanguageCode!
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Profile`.
  userById: User
}

# A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical ‘and.’
input ProfileCondition {
  # Checks for equality with the object’s `id` field.
  id: String

  # Checks for equality with the object’s `firstName` field.
  firstName: String

  # Checks for equality with the object’s `lastName` field.
  lastName: String

  # Checks for equality with the object’s `language` field.
  language: LanguageCode

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `Profile` object types. All fields are combined with a logical ‘and.’
input ProfileFilter {
  # Filter by the object’s `id` field.
  id: StringFilter

  # Filter by the object’s `firstName` field.
  firstName: StringFilter

  # Filter by the object’s `lastName` field.
  lastName: StringFilter

  # Filter by the object’s `language` field.
  language: LanguageCodeFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [ProfileFilter!]

  # Checks for any expressions in this list.
  or: [ProfileFilter!]

  # Negates the expression.
  not: ProfileFilter
}

# An input for mutations affecting `Profile`
input ProfileInput {
  id: String!
  firstName: String!
  lastName: String!
  language: LanguageCode
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `Profile`. Fields that are set will be updated.
input ProfilePatch {
  id: String
  firstName: String
  lastName: String
  language: LanguageCode
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `Profile` values.
type ProfilesConnection {
  # A list of `Profile` objects.
  nodes: [Profile]!

  # A list of edges which contains the `Profile` and cursor to aid in pagination.
  edges: [ProfilesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Profile` you could get from the connection.
  totalCount: Int!
}

# A `Profile` edge in the connection.
type ProfilesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Profile` at the end of the edge.
  node: Profile
}

# Methods to use when ordering `Profile`.
enum ProfilesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  LANGUAGE_ASC
  LANGUAGE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Project implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  code: String!
  name: String!
  body: String
  archived: Boolean
  createdBy: String
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Project`.
  userByCreatedBy: User

  # Reads and enables pagination through a set of `ProjectsOnUser`.
  projectsOnUsersByProjectId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `ProjectsOnUser`.
    orderBy: [ProjectsOnUsersOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProjectsOnUserCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProjectsOnUserFilter
  ): ProjectsOnUsersConnection!

  # Reads and enables pagination through a set of `ProjectsOnRole`.
  projectsOnRolesByProjectId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `ProjectsOnRole`.
    orderBy: [ProjectsOnRolesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProjectsOnRoleCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProjectsOnRoleFilter
  ): ProjectsOnRolesConnection!
}

# A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
input ProjectCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `code` field.
  code: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `body` field.
  body: String

  # Checks for equality with the object’s `archived` field.
  archived: Boolean

  # Checks for equality with the object’s `createdBy` field.
  createdBy: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’
input ProjectFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `code` field.
  code: StringFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `body` field.
  body: StringFilter

  # Filter by the object’s `archived` field.
  archived: BooleanFilter

  # Filter by the object’s `createdBy` field.
  createdBy: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [ProjectFilter!]

  # Checks for any expressions in this list.
  or: [ProjectFilter!]

  # Negates the expression.
  not: ProjectFilter
}

# An input for mutations affecting `Project`
input ProjectInput {
  id: Int
  code: String!
  name: String!
  body: String
  archived: Boolean
  createdBy: String
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `Project`. Fields that are set will be updated.
input ProjectPatch {
  id: Int
  code: String
  name: String
  body: String
  archived: Boolean
  createdBy: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `Project` values.
type ProjectsConnection {
  # A list of `Project` objects.
  nodes: [Project]!

  # A list of edges which contains the `Project` and cursor to aid in pagination.
  edges: [ProjectsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Project` you could get from the connection.
  totalCount: Int!
}

# A `Project` edge in the connection.
type ProjectsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Project` at the end of the edge.
  node: Project
}

type ProjectsOnRole implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  projectId: Int!
  roleId: Int!
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `Project` that is related to this `ProjectsOnRole`.
  projectByProjectId: Project

  # Reads a single `Role` that is related to this `ProjectsOnRole`.
  roleByRoleId: Role
}

# A condition to be used against `ProjectsOnRole` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ProjectsOnRoleCondition {
  # Checks for equality with the object’s `projectId` field.
  projectId: Int

  # Checks for equality with the object’s `roleId` field.
  roleId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `ProjectsOnRole` object types. All fields are combined with a logical ‘and.’
input ProjectsOnRoleFilter {
  # Filter by the object’s `projectId` field.
  projectId: IntFilter

  # Filter by the object’s `roleId` field.
  roleId: IntFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [ProjectsOnRoleFilter!]

  # Checks for any expressions in this list.
  or: [ProjectsOnRoleFilter!]

  # Negates the expression.
  not: ProjectsOnRoleFilter
}

# An input for mutations affecting `ProjectsOnRole`
input ProjectsOnRoleInput {
  projectId: Int!
  roleId: Int!
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `ProjectsOnRole`. Fields that are set will be updated.
input ProjectsOnRolePatch {
  projectId: Int
  roleId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `ProjectsOnRole` values.
type ProjectsOnRolesConnection {
  # A list of `ProjectsOnRole` objects.
  nodes: [ProjectsOnRole]!

  # A list of edges which contains the `ProjectsOnRole` and cursor to aid in pagination.
  edges: [ProjectsOnRolesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ProjectsOnRole` you could get from the connection.
  totalCount: Int!
}

# A `ProjectsOnRole` edge in the connection.
type ProjectsOnRolesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ProjectsOnRole` at the end of the edge.
  node: ProjectsOnRole
}

# Methods to use when ordering `ProjectsOnRole`.
enum ProjectsOnRolesOrderBy {
  NATURAL
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type ProjectsOnUser implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  userId: String!
  projectId: Int!
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `User` that is related to this `ProjectsOnUser`.
  userByUserId: User

  # Reads a single `Project` that is related to this `ProjectsOnUser`.
  projectByProjectId: Project
}

# A condition to be used against `ProjectsOnUser` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ProjectsOnUserCondition {
  # Checks for equality with the object’s `userId` field.
  userId: String

  # Checks for equality with the object’s `projectId` field.
  projectId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `ProjectsOnUser` object types. All fields are combined with a logical ‘and.’
input ProjectsOnUserFilter {
  # Filter by the object’s `userId` field.
  userId: StringFilter

  # Filter by the object’s `projectId` field.
  projectId: IntFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [ProjectsOnUserFilter!]

  # Checks for any expressions in this list.
  or: [ProjectsOnUserFilter!]

  # Negates the expression.
  not: ProjectsOnUserFilter
}

# An input for mutations affecting `ProjectsOnUser`
input ProjectsOnUserInput {
  userId: String!
  projectId: Int!
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `ProjectsOnUser`. Fields that are set will be updated.
input ProjectsOnUserPatch {
  userId: String
  projectId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `ProjectsOnUser` values.
type ProjectsOnUsersConnection {
  # A list of `ProjectsOnUser` objects.
  nodes: [ProjectsOnUser]!

  # A list of edges which contains the `ProjectsOnUser` and cursor to aid in pagination.
  edges: [ProjectsOnUsersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ProjectsOnUser` you could get from the connection.
  totalCount: Int!
}

# A `ProjectsOnUser` edge in the connection.
type ProjectsOnUsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ProjectsOnUser` at the end of the edge.
  node: ProjectsOnUser
}

# Methods to use when ordering `ProjectsOnUser`.
enum ProjectsOnUsersOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Methods to use when ordering `Project`.
enum ProjectsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  BODY_ASC
  BODY_DESC
  ARCHIVED_ASC
  ARCHIVED_DESC
  CREATED_BY_ASC
  CREATED_BY_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Role implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  type: RoleType!
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime

  # Reads and enables pagination through a set of `UsersOnRole`.
  usersOnRolesByRoleId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UsersOnRole`.
    orderBy: [UsersOnRolesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UsersOnRoleCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: UsersOnRoleFilter
  ): UsersOnRolesConnection!

  # Reads and enables pagination through a set of `RolesOnPermission`.
  rolesOnPermissionsByRoleId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `RolesOnPermission`.
    orderBy: [RolesOnPermissionsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: RolesOnPermissionCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: RolesOnPermissionFilter
  ): RolesOnPermissionsConnection!

  # Reads and enables pagination through a set of `ProjectsOnRole`.
  projectsOnRolesByRoleId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `ProjectsOnRole`.
    orderBy: [ProjectsOnRolesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProjectsOnRoleCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProjectsOnRoleFilter
  ): ProjectsOnRolesConnection!
}

# A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
input RoleCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `type` field.
  type: RoleType

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `builtin` field.
  builtin: Boolean

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’
input RoleFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `type` field.
  type: RoleTypeFilter

  # Filter by the object’s `description` field.
  description: StringFilter

  # Filter by the object’s `builtin` field.
  builtin: BooleanFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [RoleFilter!]

  # Checks for any expressions in this list.
  or: [RoleFilter!]

  # Negates the expression.
  not: RoleFilter
}

# An input for mutations affecting `Role`
input RoleInput {
  id: Int
  name: String!
  type: RoleType
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `Role`. Fields that are set will be updated.
input RolePatch {
  id: Int
  name: String
  type: RoleType
  description: String
  builtin: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `Role` values.
type RolesConnection {
  # A list of `Role` objects.
  nodes: [Role]!

  # A list of edges which contains the `Role` and cursor to aid in pagination.
  edges: [RolesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Role` you could get from the connection.
  totalCount: Int!
}

# A `Role` edge in the connection.
type RolesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Role` at the end of the edge.
  node: Role
}

type RolesOnPermission implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  roleId: Int!
  permissionId: Int!
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `Role` that is related to this `RolesOnPermission`.
  roleByRoleId: Role

  # Reads a single `Permission` that is related to this `RolesOnPermission`.
  permissionByPermissionId: Permission
}

# A condition to be used against `RolesOnPermission` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input RolesOnPermissionCondition {
  # Checks for equality with the object’s `roleId` field.
  roleId: Int

  # Checks for equality with the object’s `permissionId` field.
  permissionId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `RolesOnPermission` object types. All fields are combined with a logical ‘and.’
input RolesOnPermissionFilter {
  # Filter by the object’s `roleId` field.
  roleId: IntFilter

  # Filter by the object’s `permissionId` field.
  permissionId: IntFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [RolesOnPermissionFilter!]

  # Checks for any expressions in this list.
  or: [RolesOnPermissionFilter!]

  # Negates the expression.
  not: RolesOnPermissionFilter
}

# An input for mutations affecting `RolesOnPermission`
input RolesOnPermissionInput {
  roleId: Int!
  permissionId: Int!
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `RolesOnPermission`. Fields that are set will be updated.
input RolesOnPermissionPatch {
  roleId: Int
  permissionId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `RolesOnPermission` values.
type RolesOnPermissionsConnection {
  # A list of `RolesOnPermission` objects.
  nodes: [RolesOnPermission]!

  # A list of edges which contains the `RolesOnPermission` and cursor to aid in pagination.
  edges: [RolesOnPermissionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `RolesOnPermission` you could get from the connection.
  totalCount: Int!
}

# A `RolesOnPermission` edge in the connection.
type RolesOnPermissionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `RolesOnPermission` at the end of the edge.
  node: RolesOnPermission
}

# Methods to use when ordering `RolesOnPermission`.
enum RolesOnPermissionsOrderBy {
  NATURAL
  ROLE_ID_ASC
  ROLE_ID_DESC
  PERMISSION_ID_ASC
  PERMISSION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Methods to use when ordering `Role`.
enum RolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  TYPE_ASC
  TYPE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  BUILTIN_ASC
  BUILTIN_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

enum RoleType {
  SYSTEM
  PROJECT
}

# A filter to be used against RoleType fields. All fields are combined with a logical ‘and.’
input RoleTypeFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: RoleType

  # Not equal to the specified value.
  notEqualTo: RoleType

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: RoleType

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: RoleType

  # Included in the specified list.
  in: [RoleType!]

  # Not included in the specified list.
  notIn: [RoleType!]

  # Less than the specified value.
  lessThan: RoleType

  # Less than or equal to the specified value.
  lessThanOrEqualTo: RoleType

  # Greater than the specified value.
  greaterThan: RoleType

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: RoleType
}

# A filter to be used against String fields. All fields are combined with a logical ‘and.’
input StringFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: String

  # Not equal to the specified value.
  notEqualTo: String

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: String

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: String

  # Included in the specified list.
  in: [String!]

  # Not included in the specified list.
  notIn: [String!]

  # Less than the specified value.
  lessThan: String

  # Less than or equal to the specified value.
  lessThanOrEqualTo: String

  # Greater than the specified value.
  greaterThan: String

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: String

  # Contains the specified string (case-sensitive).
  includes: String

  # Does not contain the specified string (case-sensitive).
  notIncludes: String

  # Contains the specified string (case-insensitive).
  includesInsensitive: String

  # Does not contain the specified string (case-insensitive).
  notIncludesInsensitive: String

  # Starts with the specified string (case-sensitive).
  startsWith: String

  # Does not start with the specified string (case-sensitive).
  notStartsWith: String

  # Starts with the specified string (case-insensitive).
  startsWithInsensitive: String

  # Does not start with the specified string (case-insensitive).
  notStartsWithInsensitive: String

  # Ends with the specified string (case-sensitive).
  endsWith: String

  # Does not end with the specified string (case-sensitive).
  notEndsWith: String

  # Ends with the specified string (case-insensitive).
  endsWithInsensitive: String

  # Does not end with the specified string (case-insensitive).
  notEndsWithInsensitive: String

  # Matches the specified pattern (case-sensitive). An underscore (_) matches any
  # single character; a percent sign (%) matches any sequence of zero or more characters.
  like: String

  # Does not match the specified pattern (case-sensitive). An underscore (_)
  # matches any single character; a percent sign (%) matches any sequence of zero
  # or more characters.
  notLike: String

  # Matches the specified pattern (case-insensitive). An underscore (_) matches
  # any single character; a percent sign (%) matches any sequence of zero or more characters.
  likeInsensitive: String

  # Does not match the specified pattern (case-insensitive). An underscore (_)
  # matches any single character; a percent sign (%) matches any sequence of zero
  # or more characters.
  notLikeInsensitive: String

  # Equal to the specified value (case-insensitive).
  equalToInsensitive: String

  # Not equal to the specified value (case-insensitive).
  notEqualToInsensitive: String

  # Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  distinctFromInsensitive: String

  # Equal to the specified value, treating null like an ordinary value (case-insensitive).
  notDistinctFromInsensitive: String

  # Included in the specified list (case-insensitive).
  inInsensitive: [String!]

  # Not included in the specified list (case-insensitive).
  notInInsensitive: [String!]

  # Less than the specified value (case-insensitive).
  lessThanInsensitive: String

  # Less than or equal to the specified value (case-insensitive).
  lessThanOrEqualToInsensitive: String

  # Greater than the specified value (case-insensitive).
  greaterThanInsensitive: String

  # Greater than or equal to the specified value (case-insensitive).
  greaterThanOrEqualToInsensitive: String
}

# All input for the `updateOrganizationById` mutation.
input UpdateOrganizationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Organization` being updated.
  organizationPatch: OrganizationPatch!
  id: Int!
}

# All input for the `updateOrganization` mutation.
input UpdateOrganizationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Organization` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Organization` being updated.
  organizationPatch: OrganizationPatch!
}

# The output of our update `Organization` mutation.
type UpdateOrganizationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Organization` that was updated by this mutation.
  organization: Organization

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Organization`. May be used by Relay 1.
  organizationEdge(
    # The method to use when ordering `Organization`.
    orderBy: [OrganizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

# All input for the `updatePermissionById` mutation.
input UpdatePermissionByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Permission` being updated.
  permissionPatch: PermissionPatch!
  id: Int!
}

# All input for the `updatePermission` mutation.
input UpdatePermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Permission` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Permission` being updated.
  permissionPatch: PermissionPatch!
}

# The output of our update `Permission` mutation.
type UpdatePermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Permission` that was updated by this mutation.
  permission: Permission

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Permission`. May be used by Relay 1.
  permissionEdge(
    # The method to use when ordering `Permission`.
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

# All input for the `updateProfileById` mutation.
input UpdateProfileByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Profile` being updated.
  profilePatch: ProfilePatch!
  id: String!
}

# All input for the `updateProfile` mutation.
input UpdateProfileInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Profile` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Profile` being updated.
  profilePatch: ProfilePatch!
}

# The output of our update `Profile` mutation.
type UpdateProfilePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Profile` that was updated by this mutation.
  profile: Profile

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Profile`.
  userById: User

  # An edge for our `Profile`. May be used by Relay 1.
  profileEdge(
    # The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProfilesEdge
}

# All input for the `updateProjectById` mutation.
input UpdateProjectByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Project` being updated.
  projectPatch: ProjectPatch!
  id: Int!
}

# All input for the `updateProject` mutation.
input UpdateProjectInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Project` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Project` being updated.
  projectPatch: ProjectPatch!
}

# The output of our update `Project` mutation.
type UpdateProjectPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Project` that was updated by this mutation.
  project: Project

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Project`.
  userByCreatedBy: User

  # An edge for our `Project`. May be used by Relay 1.
  projectEdge(
    # The method to use when ordering `Project`.
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

# All input for the `updateProjectsOnRoleByProjectIdAndRoleId` mutation.
input UpdateProjectsOnRoleByProjectIdAndRoleIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `ProjectsOnRole` being updated.
  projectsOnRolePatch: ProjectsOnRolePatch!
  projectId: Int!
  roleId: Int!
}

# All input for the `updateProjectsOnRole` mutation.
input UpdateProjectsOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ProjectsOnRole` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ProjectsOnRole` being updated.
  projectsOnRolePatch: ProjectsOnRolePatch!
}

# The output of our update `ProjectsOnRole` mutation.
type UpdateProjectsOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnRole` that was updated by this mutation.
  projectsOnRole: ProjectsOnRole

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Project` that is related to this `ProjectsOnRole`.
  projectByProjectId: Project

  # Reads a single `Role` that is related to this `ProjectsOnRole`.
  roleByRoleId: Role

  # An edge for our `ProjectsOnRole`. May be used by Relay 1.
  projectsOnRoleEdge(
    # The method to use when ordering `ProjectsOnRole`.
    orderBy: [ProjectsOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnRolesEdge
}

# All input for the `updateProjectsOnUserByUserIdAndProjectId` mutation.
input UpdateProjectsOnUserByUserIdAndProjectIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `ProjectsOnUser` being updated.
  projectsOnUserPatch: ProjectsOnUserPatch!
  userId: String!
  projectId: Int!
}

# All input for the `updateProjectsOnUser` mutation.
input UpdateProjectsOnUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ProjectsOnUser` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ProjectsOnUser` being updated.
  projectsOnUserPatch: ProjectsOnUserPatch!
}

# The output of our update `ProjectsOnUser` mutation.
type UpdateProjectsOnUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ProjectsOnUser` that was updated by this mutation.
  projectsOnUser: ProjectsOnUser

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `ProjectsOnUser`.
  userByUserId: User

  # Reads a single `Project` that is related to this `ProjectsOnUser`.
  projectByProjectId: Project

  # An edge for our `ProjectsOnUser`. May be used by Relay 1.
  projectsOnUserEdge(
    # The method to use when ordering `ProjectsOnUser`.
    orderBy: [ProjectsOnUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsOnUsersEdge
}

# All input for the `updateRoleById` mutation.
input UpdateRoleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Role` being updated.
  rolePatch: RolePatch!
  id: Int!
}

# All input for the `updateRole` mutation.
input UpdateRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Role` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Role` being updated.
  rolePatch: RolePatch!
}

# The output of our update `Role` mutation.
type UpdateRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Role` that was updated by this mutation.
  role: Role

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `Role`. May be used by Relay 1.
  roleEdge(
    # The method to use when ordering `Role`.
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

# All input for the `updateRolesOnPermissionByRoleIdAndPermissionId` mutation.
input UpdateRolesOnPermissionByRoleIdAndPermissionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `RolesOnPermission` being updated.
  rolesOnPermissionPatch: RolesOnPermissionPatch!
  roleId: Int!
  permissionId: Int!
}

# All input for the `updateRolesOnPermission` mutation.
input UpdateRolesOnPermissionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `RolesOnPermission` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `RolesOnPermission` being updated.
  rolesOnPermissionPatch: RolesOnPermissionPatch!
}

# The output of our update `RolesOnPermission` mutation.
type UpdateRolesOnPermissionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `RolesOnPermission` that was updated by this mutation.
  rolesOnPermission: RolesOnPermission

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Role` that is related to this `RolesOnPermission`.
  roleByRoleId: Role

  # Reads a single `Permission` that is related to this `RolesOnPermission`.
  permissionByPermissionId: Permission

  # An edge for our `RolesOnPermission`. May be used by Relay 1.
  rolesOnPermissionEdge(
    # The method to use when ordering `RolesOnPermission`.
    orderBy: [RolesOnPermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesOnPermissionsEdge
}

# All input for the `updateUserById` mutation.
input UpdateUserByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
  id: String!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
}

# The output of our update `User` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was updated by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

# All input for the `updateUsersOnRoleByUserIdAndRoleId` mutation.
input UpdateUsersOnRoleByUserIdAndRoleIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UsersOnRole` being updated.
  usersOnRolePatch: UsersOnRolePatch!
  userId: String!
  roleId: Int!
}

# All input for the `updateUsersOnRole` mutation.
input UpdateUsersOnRoleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UsersOnRole` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `UsersOnRole` being updated.
  usersOnRolePatch: UsersOnRolePatch!
}

# The output of our update `UsersOnRole` mutation.
type UpdateUsersOnRolePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UsersOnRole` that was updated by this mutation.
  usersOnRole: UsersOnRole

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `UsersOnRole`.
  userByUserId: User

  # Reads a single `Role` that is related to this `UsersOnRole`.
  roleByRoleId: Role

  # An edge for our `UsersOnRole`. May be used by Relay 1.
  usersOnRoleEdge(
    # The method to use when ordering `UsersOnRole`.
    orderBy: [UsersOnRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersOnRolesEdge
}

type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: String!
  username: String!
  email: String!
  name: String
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `Profile` that is related to this `User`.
  profileById: Profile

  # Reads and enables pagination through a set of `Profile`.
  profilesById(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Profile`.
    orderBy: [ProfilesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProfileCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProfileFilter
  ): ProfilesConnection! @deprecated(reason: "Please use profileById instead")

  # Reads and enables pagination through a set of `UsersOnRole`.
  usersOnRolesByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UsersOnRole`.
    orderBy: [UsersOnRolesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UsersOnRoleCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: UsersOnRoleFilter
  ): UsersOnRolesConnection!

  # Reads and enables pagination through a set of `Project`.
  projectsByCreatedBy(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Project`.
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProjectCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProjectFilter
  ): ProjectsConnection!

  # Reads and enables pagination through a set of `ProjectsOnUser`.
  projectsOnUsersByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `ProjectsOnUser`.
    orderBy: [ProjectsOnUsersOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ProjectsOnUserCondition

    # A filter to be used in determining which values should be returned by the collection.
    filter: ProjectsOnUserFilter
  ): ProjectsOnUsersConnection!
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `id` field.
  id: String

  # Checks for equality with the object’s `username` field.
  username: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `avatarUrl` field.
  avatarUrl: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
input UserFilter {
  # Filter by the object’s `id` field.
  id: StringFilter

  # Filter by the object’s `username` field.
  username: StringFilter

  # Filter by the object’s `email` field.
  email: StringFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `avatarUrl` field.
  avatarUrl: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [UserFilter!]

  # Checks for any expressions in this list.
  or: [UserFilter!]

  # Negates the expression.
  not: UserFilter
}

# An input for mutations affecting `User`
input UserInput {
  id: String!
  username: String!
  email: String!
  name: String
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  id: String
  username: String
  email: String
  name: String
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `User` values.
type UsersConnection {
  # A list of `User` objects.
  nodes: [User]!

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int!
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User
}

type UsersOnRole implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  userId: String!
  roleId: Int!
  createdAt: Datetime
  updatedAt: Datetime

  # Reads a single `User` that is related to this `UsersOnRole`.
  userByUserId: User

  # Reads a single `Role` that is related to this `UsersOnRole`.
  roleByRoleId: Role
}

# A condition to be used against `UsersOnRole` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input UsersOnRoleCondition {
  # Checks for equality with the object’s `userId` field.
  userId: String

  # Checks for equality with the object’s `roleId` field.
  roleId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A filter to be used against `UsersOnRole` object types. All fields are combined with a logical ‘and.’
input UsersOnRoleFilter {
  # Filter by the object’s `userId` field.
  userId: StringFilter

  # Filter by the object’s `roleId` field.
  roleId: IntFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [UsersOnRoleFilter!]

  # Checks for any expressions in this list.
  or: [UsersOnRoleFilter!]

  # Negates the expression.
  not: UsersOnRoleFilter
}

# An input for mutations affecting `UsersOnRole`
input UsersOnRoleInput {
  userId: String!
  roleId: Int!
  createdAt: Datetime
  updatedAt: Datetime
}

# Represents an update to a `UsersOnRole`. Fields that are set will be updated.
input UsersOnRolePatch {
  userId: String
  roleId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

# A connection to a list of `UsersOnRole` values.
type UsersOnRolesConnection {
  # A list of `UsersOnRole` objects.
  nodes: [UsersOnRole]!

  # A list of edges which contains the `UsersOnRole` and cursor to aid in pagination.
  edges: [UsersOnRolesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `UsersOnRole` you could get from the connection.
  totalCount: Int!
}

# A `UsersOnRole` edge in the connection.
type UsersOnRolesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `UsersOnRole` at the end of the edge.
  node: UsersOnRole
}

# Methods to use when ordering `UsersOnRole`.
enum UsersOnRolesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  NAME_ASC
  NAME_DESC
  AVATAR_URL_ASC
  AVATAR_URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}
